<!DOCTYPE html>
<html>
<head>
    <title>Bluesky Tunnel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        let rotationDir = 1;
        const scene = new THREE.Scene();
        // background black
        scene.background = new THREE.Color(0x000000);
        // fog at the end of the tunnel
        scene.fog = new THREE.Fog(0x000000, 1, 50);

        const camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        document.body.appendChild(renderer.domElement);

        const tunnelLength = 40;
        const tunnelGeometry = new THREE.BoxGeometry(15, 15, tunnelLength);
        const tunnelMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x111111, 
            side: THREE.BackSide 
        });
        const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
        //scene.add(tunnel);

        camera.position.z = 8;
        camera.position.y = 1;
        camera.rotation.x = -0.1;

        const messageObjects = [];
        let lastTime = 0;

        // Previous text wrapping and texture creation functions remain the same...
        function wrapText(context, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = context.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            const fontSize = 32;
            context.font = `bold ${fontSize}px sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            const maxWidth = 650;
            const lines = wrapText(context, text, maxWidth);
            const lineHeight = fontSize * 1.1;
            const totalHeight = lines.length * lineHeight;
            const startY = (canvas.height - totalHeight) / 2;

            const r = Math.floor(Math.random() * 200 + 55);
            const g = Math.floor(Math.random() * 200 + 55);
            const b = Math.floor(Math.random() * 200 + 55);
            const fillStyle = `rgba(${r}, ${g}, ${b},0.7)`;

            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight) + lineHeight/2;
                context.shadowBlur = 10;
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillText(line, canvas.width/2, y);
                context.fillStyle = fillStyle;
                context.fillText(line, canvas.width/2, y);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { 
                texture,
                lineCount: lines.length
            };
        }

        function createMessage(text) {
            const { texture, lineCount } = createTextTexture(text);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                depthTest: true,
              //  blending: THREE.CustomBlending,
               // blendEquation: THREE.AddEquation,
               // blendSrc: THREE.SrcAlphaFactor,
               // blendDst: THREE.OneMinusSrcAlphaFactor,
                side: THREE.DoubleSide
            });

            const height = Math.max(1.5, lineCount * 0.75);
            const geometry = new THREE.PlaneGeometry(6, height);
            const mesh = new THREE.Mesh(geometry, material);
            
            let wall = Math.floor(Math.random() * 4.01);
            mesh.position.z = -tunnelLength;
            
            const randomOffset = Math.random() * 0.5;
            if (text.includes('ðŸ”¥')|| wall>3){
                wall = -1;
            }

            
            switch(wall) {
                case -1: // center
                // invisible
                    const centerExtent=10
                
                    const getCoordsNotInCenter = () => {
                        const x = (Math.random()) * centerExtent - centerExtent/2;
                        const y = (Math.random()) * centerExtent - centerExtent/2;
                        if (Math.sqrt(x*x + y*y) < 2) {
                            return getCoordsNotInCenter();
                        }
                        return { x, y };
                    };
                    const { x, y } = getCoordsNotInCenter();
                    mesh.position.x = x;
                    mesh.position.y = y;
                    
                    break;

                case 0: // right wall
                    mesh.position.x = 7.4;
                    mesh.position.y = Math.random() * 12 - 6;
                    mesh.rotation.y = -Math.PI/2;
                    break;
                case 1: // left wall
                    mesh.position.x = -7.4;
                    mesh.position.y = Math.random() * 12 - 6;
                    mesh.rotation.y = Math.PI/2;
                    break;
                case 2: // top wall
                    mesh.position.x = Math.random() * 12 - 6;
                    mesh.position.y = 7.4;
                    mesh.rotation.x = Math.PI/2;
                    break;
                case 3: // bottom wall
                    mesh.position.x = Math.random() * 12 - 6;
                    mesh.position.y = -7.4;
                    mesh.rotation.x = -Math.PI/2;
                    break;
                
            }
            
            mesh.position.z += randomOffset;
            mesh.renderOrder = -mesh.position.z;
            
            scene.add(mesh);
            messageObjects.push({
                mesh: mesh,
                speed: 0.5*(0.08 + Math.random() * 0.12),
                createdAt: performance.now()
            });
        }

        const ws = new WebSocket('wss://jetstream2.us-east.bsky.network/subscribe?wantedCollections=app.bsky.feed.post');
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.commit && data.commit.record && data.commit.record.text) {
                createMessage(data.commit.record.text);
            }
        };

        ws.onerror = function(error) {
            console.error('WebSocket Error:', error);
        };

        ws.onclose = function() {
            console.log('WebSocket Connection Closed');
        };

        function animate(currentTime) {
            requestAnimationFrame(animate);

            // Calculate time delta
            const deltaTime = lastTime === 0 ? 0 : (currentTime - lastTime) / 16.667; // Normalize to ~60fps
            lastTime = currentTime;
            const rotationExtent = 0.3;
           
            camera.rotation.z += deltaTime * 0.0005 * rotationDir;
            if (camera.rotation.z > rotationExtent) {
                rotationDir = -1;
            } else if (camera.rotation.z < -rotationExtent) {
                rotationDir = 1;
            }


            for (let i = messageObjects.length - 1; i >= 0; i--) {
                const message = messageObjects[i];
                
                // Apply time-based movement
                message.mesh.position.z += message.speed * deltaTime;
                message.mesh.renderOrder = -message.mesh.position.z;

                // Calculate age-based effects
                const age = currentTime - message.createdAt;
                
                // Fade out messages as they get closer to the camera
                if (message.mesh.position.z > 5) {
                    const fadeOutProgress = (message.mesh.position.z - 5) / 5;
                    message.mesh.material.opacity = 1 - fadeOutProgress;
                }

                if (message.mesh.position.z > 10) {
                    scene.remove(message.mesh);
                    message.mesh.geometry.dispose();
                    message.mesh.material.map.dispose();
                    message.mesh.material.dispose();
                    messageObjects.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate(0);
    </script>
</body>
</html>