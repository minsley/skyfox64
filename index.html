<!DOCTYPE html>
<html>
<head>
    <title>Bluesky Tunnel</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { margin: 0; }
        canvas { display: block; }
    </style>
</head>
<body>
    <script>
        // Previous setup code remains the same...
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(110, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.sortObjects = false;
        document.body.appendChild(renderer.domElement);

        const tunnelLength = 50;
        const tunnelGeometry = new THREE.BoxGeometry(15, 15, tunnelLength);
        const tunnelMaterial = new THREE.MeshBasicMaterial({ 
            color: 0x111111, 
            side: THREE.BackSide 
        });
        const tunnel = new THREE.Mesh(tunnelGeometry, tunnelMaterial);
        scene.add(tunnel);

        camera.position.z = 8;
        camera.position.y = 1;
        camera.rotation.x = -0.1;

        const messageObjects = [];

        // Previous text wrapping and texture creation functions remain the same...
        function wrapText(context, text, maxWidth) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            for (let i = 1; i < words.length; i++) {
                const word = words[i];
                const width = context.measureText(currentLine + " " + word).width;
                if (width < maxWidth) {
                    currentLine += " " + word;
                } else {
                    lines.push(currentLine);
                    currentLine = word;
                }
            }
            lines.push(currentLine);
            return lines;
        }

        function createTextTexture(text) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 512;
            canvas.height = 256;
            
            context.clearRect(0, 0, canvas.width, canvas.height);
            
            const fontSize = 32;
            context.font = `bold ${fontSize}px sans-serif`;
            context.textAlign = 'center';
            context.textBaseline = 'middle';

            
            const maxWidth = 650;
            const lines = wrapText(context, text, maxWidth);
            const lineHeight = fontSize * 1.1;
            const totalHeight = lines.length * lineHeight;
            const startY = (canvas.height - totalHeight) / 2;

            // get random bright color
            const r = Math.floor(Math.random() * 200 + 55);
            const g = Math.floor(Math.random() * 200 + 55);
            const b = Math.floor(Math.random() * 200 + 55);
            const fillStyle = `rgba(${r}, ${g}, ${b},0.7)`;



            lines.forEach((line, index) => {
                const y = startY + (index * lineHeight) + lineHeight/2;
                
                for(let i = 15; i >= 0; i -= 5) {
                    //context.shadowBlur = i;
                    //context.shadowColor = '#00ff00';
                    //context.fillStyle = `rgba(0, 255, 0, ${0.3 - i * 0.01})`;
                    //context.fillText(line, canvas.width/2, y);
                }
                
                context.shadowBlur = 0;
                context.fillStyle = 'rgba(255, 255, 255, 0.9)';
                context.fillText(line, canvas.width/2, y);

                
                
                context.fillStyle = fillStyle;
                context.fillText(line, canvas.width/2, y);
            });
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return { 
                texture,
                lineCount: lines.length
            };
        }

        function createMessage(text) {
            const { texture, lineCount } = createTextTexture(text);
            const material = new THREE.MeshBasicMaterial({ 
                map: texture,
                transparent: true,
                opacity: 1,
                depthWrite: false,
                depthTest: true,
                blending: THREE.CustomBlending,
                blendEquation: THREE.AddEquation,
                blendSrc: THREE.SrcAlphaFactor,
                blendDst: THREE.OneMinusSrcAlphaFactor,
                side: THREE.DoubleSide
            });

            const height = Math.max(1.5, lineCount * 0.75);
            const geometry = new THREE.PlaneGeometry(6, height);
            const mesh = new THREE.Mesh(geometry, material);
            
            const wall = Math.floor(Math.random() * 5);
            mesh.position.z = -tunnelLength;
            
            const randomOffset = Math.random() * 0.5;
            
            switch(wall) {
                case 0: // right wall
                    mesh.position.x = 7.4;
                    mesh.position.y = Math.random() * 12 - 6;
                    mesh.rotation.y = -Math.PI/2;
                    break;
                case 1: // left wall
                    mesh.position.x = -7.4;
                    mesh.position.y = Math.random() * 12 - 6;
                    mesh.rotation.y = Math.PI/2;
                    //mesh.rotation.z =0 ; // Flip the text upright on the left wall
                    
                    break;
                case 2: // top wall
                    mesh.position.x = Math.random() * 12 - 6;
                    mesh.position.y = 7.4;
                    mesh.rotation.x = Math.PI/2;
                    break;
                case 3: // bottom wall
                    mesh.position.x = Math.random() * 12 - 6;
                    mesh.position.y = -7.4;
                    mesh.rotation.x = -Math.PI/2;
                    break;
                case 4: // center
                // don't allow text to be placed in the very center
                    //mesh.position.x = (0.5+Math.random()) * 12 - 6;
                    //mesh.position.y = (0.5+Math.random()) * 12 - 6;
                    const getCoordsNotInCenter = () => {
                        const x = (Math.random()) * 12 - 6;
                        const y = (Math.random()) * 12 - 6;
                        if (Math.sqrt(x*x + y*y) < 2) {
                            return getCoordsNotInCenter();
                        }
                        return { x, y };
                    };
                    const { x, y } = getCoordsNotInCenter();
                    mesh.position.x = x;
                    mesh.position.y = y;

                    break;
            }
            
            mesh.position.z += randomOffset;
            mesh.renderOrder = -mesh.position.z;
            
            scene.add(mesh);
            messageObjects.push({
                mesh: mesh,
                speed: 0.5*(0.08 + Math.random() * 0.12)
            });
        }

        const ws = new WebSocket('wss://jetstream2.us-east.bsky.network/subscribe?wantedCollections=app.bsky.feed.post');
        
        ws.onmessage = function(event) {
            const data = JSON.parse(event.data);
            if (data.commit && data.commit.record && data.commit.record.text) {
                createMessage(data.commit.record.text);
            }
        };

        ws.onerror = function(error) {
            console.error('WebSocket Error:', error);
        };

        ws.onclose = function() {
            console.log('WebSocket Connection Closed');
        };

        function animate(currentTime) {
            requestAnimationFrame(animate);

            for (let i = messageObjects.length - 1; i >= 0; i--) {
                const message = messageObjects[i];
                message.mesh.position.z += message.speed;
                message.mesh.renderOrder = -message.mesh.position.z;

                if (message.mesh.position.z > 10) {
                    scene.remove(message.mesh);
                    message.mesh.geometry.dispose();
                    message.mesh.material.map.dispose();
                    message.mesh.material.dispose();
                    messageObjects.splice(i, 1);
                }
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', onWindowResize, false);

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        animate(0);
    </script>
</body>
</html>